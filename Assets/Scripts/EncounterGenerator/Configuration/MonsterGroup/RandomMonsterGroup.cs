using System.Collections.Generic;
using System.Linq;
using Assets.Scripts.Combat;
using Assets.Scripts.EncounterGenerator.Model;
using UnityEngine;

namespace Assets.Scripts.EncounterGenerator.Configuration.MonsterGroup
{
    /// <summary>
    /// <inheritdoc/>
    /// When asked for a group of monsters, this class will just pick monsters randomly from a set of monsters given by the designer.
    /// It will ignore the difficulty and the monster weights.
    /// TODO: Modify this class to take the monster weights into account.
    /// </summary>
    [CreateAssetMenu(menuName = "Encounter generator/Monster Groups/Random Monster Group", fileName = "Random Monster Group")]
    public class RandomMonsterGroup : MonsterGroupDefinition
    {
        /// <summary>
        /// List of all monsters that can be generated by the algorithm for this monster group definition.
        /// </summary>
        public List<GameObject> AllowedMonsters;
        /// <summary>
        /// Generates a list of monsters based on a request from the encounter generator. If the request cannot be satisfied, returns null.
        /// </summary>
        /// <param name="parameters">The parameters from the encounter generator.</param>
        /// <returns> The list of prefabs for monster which should then be instantiated.</returns>
        public override List<GameObject> GenerateMonsterGroup(GenerateMonsterGroupParameters parameters)
        {
            List<GameObject> toReturn = new List<GameObject>();
            var random = new System.Random(); 
            foreach (var monsterRequest in parameters.RequestedMonsters.AllEncounterGroups)
            {
                var possibleMonsters = GetMonstersFor(monsterRequest.MonsterType);
                if (!possibleMonsters.Any())
                {
                    // Could not satisfy the request.
                    return null;
                }
                for (int i = 0; i < monsterRequest.MonsterCount; ++i)
                {
                    toReturn.Add(possibleMonsters[random.Next(possibleMonsters.Count)]);
                }
            }
            return toReturn;
        }
        /// <summary>
        /// <inheritdoc/>
        /// </summary>
        /// <returns>The list of monster types this group definition can spawn.</returns>
        public override List<MonsterType> GetAvailableMonsterTypes()
        {
            HashSet<MonsterType> availableMonsterTypes = new HashSet<MonsterType>();
            foreach(var monster in AllowedMonsters)
            {
                if (monster == null)
                {
                    continue;
                }
                var monsterComponent = monster.GetComponent<Monster>();
                availableMonsterTypes.Add(new MonsterType(monsterComponent.Rank, monsterComponent.Role));
            }
            return availableMonsterTypes.ToList();
        }

        /// <summary>
        /// Filters from the prefabs monsters which are of the specified type.
        /// </summary>
        /// <param name="monsterTypeDefinition">We only want monsters of this type.</param>
        /// <returns>The list of monsters we can generate of the specified type.</returns>
        protected List<GameObject> GetMonstersFor(MonsterType monsterTypeDefinition)
        {
            return AllowedMonsters?.Where(monsterObject =>
            {
                if (monsterObject == null)
                {
                    return false;
                }
                var monster = monsterObject.GetComponent<Monster>();
                if (monster == null)
                {
                    return false;
                }
                return monster.Rank == monsterTypeDefinition.Rank && monster.Role == monsterTypeDefinition.Role;
            }).ToList() ?? new List<GameObject>();
        }
    }
}
using System.Collections.Generic;
using Assets.Scripts.Combat;

namespace Assets.Scripts.EncounterGenerator.Configuration
{
    public class EncounterGeneratorConfiguration
    {
        /// <summary>
        /// How to individual roles correspond to either defense or offense of the group.
        /// </summary>
        public Dictionary<MonsterRole, float> MonsterRoleAttackDefenseRatios = new Dictionary<MonsterRole, float>
        {
            { MonsterRole.Brute, 0.5f },
            { MonsterRole.Leader,  1f },
            { MonsterRole.Lurker,  3f },
            { MonsterRole.Minion,  1f },
            { MonsterRole.Sniper,  2f },
        };

        /// <summary>
        /// How many regular monsters is the specified monster rank worth.
        /// </summary>
        public Dictionary<MonsterRank, float> MonsterRankWeights = new Dictionary<MonsterRank, float>
        {
            { MonsterRank.Minion, 0.2f },
            { MonsterRank.Regular, 1f },
            { MonsterRank.Elite, 2f },
            { MonsterRank.Boss, 4f },
        };

        /// <summary>
        /// How likely the specified type should appear. Regular is not included, as that is the fallback if no other type is generated.
        /// </summary>
        public Dictionary<MonsterRank, float> MonsterRankProbabilities = new Dictionary<MonsterRank, float>
        {
            { MonsterRank.Minion, 0.25f },
            { MonsterRank.Elite, 0.4f },
            { MonsterRank.Boss, 0f }, // Bosses should not be generated by chance.
        };

        /// <summary>
        /// How much should the algorithm try to change its data based on actual battles. 0 means no learning at all, 1 means that it should completely change the matrix to fit the data.
        /// </summary>
        public float LearningSpeed;

    }
}

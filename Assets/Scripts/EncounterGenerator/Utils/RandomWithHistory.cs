using System.Collections.Generic;
using System.Linq;
using Assets.Scripts.Extension;

namespace Assets.Scripts.EncounterGenerator.Utils
{
    /// <summary>
    /// Class that can generate a random element from a given set, recording history of generated elements and avoids generating of the same elements multiple times in a row. 
    /// </summary>
    /// <typeparam name="T">The type of elements that can be generated by this class.</typeparam>
    class RandomWithHistory<T>
    {
        /// <summary>
        /// Weights for elements that can be generated by this class. Whenever some element is not generated, its weight increase. Whenever it is generated, the weight is reset to 1
        /// This should ensure that the same elements are not used all the time.
        /// </summary>
        readonly Dictionary<T, int> randomWeights = new Dictionary<T, int>();
        /// <summary>
        /// Retrieve a random element from some sequence. Elements which were generated recently have a lower chance of being selected.
        /// </summary>
        /// <param name="sequence">Sequence of elements from which we should choose a random element.</param>
        /// <returns>A random element from the sequence.</returns>
        public T RandomElementFromSequence(IEnumerable<T> sequence)
        {
            if (!sequence.Any())
            {
                return default;
            }
            var toReturn =  sequence.GetWeightedRandomElementOrDefault(element => randomWeights.ContainsKey(element) ? randomWeights[element] : 100);
            foreach (var key in randomWeights.Keys.ToList())
            {
                randomWeights[key]++;
            }
            randomWeights[toReturn] = 1;
            return toReturn;
        }
    }
}

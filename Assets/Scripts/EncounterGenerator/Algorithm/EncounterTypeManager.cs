using System.Collections.Generic;
using System.Linq;
using Assets.Scripts.Combat;
using Assets.Scripts.EncounterGenerator.Configuration;
using Assets.Scripts.EncounterGenerator.Model;
using Assets.Scripts.Extension;

namespace Assets.Scripts.EncounterGenerator.Algorithm
{
    /// <summary>
    /// This class can select an encounter type for the next generated encounter. Encounter type is a high level overview of the encounter, meant to ensure variance in encounters.
    /// It keeps history and tries to select different encounter types.
    /// </summary>
    public class EncounterTypeManager
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EncounterTypeManager"/> class.
        /// </summary>
        /// <param name="configuration">The general configuration for the encounter generator.</param>
        public EncounterTypeManager(EncounterGeneratorConfiguration configuration)
        {
            Configuration = configuration;
            FillPossibleEncounterTypes();
        }
        /// <summary>
        /// The general configuration for the encounter generator.
        /// </summary>
        public EncounterGeneratorConfiguration Configuration;
        /// <summary>
        /// Weights specifying how likely each encounter type is to be selected.
        /// All weights start with the value 1.
        /// Whenever an encounter type is selected, all weights are incremented except for the selected encounter type, which is reset to 1.
        /// </summary>
        readonly Dictionary<EncounterType, int> encounterTypeWeights = new Dictionary<EncounterType, int>();
        /// <summary>
        /// Selects an encounter type for the next encounter to be generated. Tries to select encounter types which were not selected in some time.
        /// </summary>
        /// <param name="availableMonsterTypes">The monster types we are allowed to generate by the designer.</param>
        /// <returns>The selected encounter.</returns>
        public EncounterType SelectEncounterType(List<MonsterType> availableMonsterTypes)
        {
            bool canHaveBoss = availableMonsterTypes.Any(p => p.Rank == MonsterRank.Boss);
            bool canHaveLeader = availableMonsterTypes.Any(p => p.Role == MonsterRole.Leader);
            float minAttackToDefenseRatio = availableMonsterTypes.Min(p => Configuration.MonsterRoleAttackDefenseRatios[p.Role]);
            float maxsAttackToDefenseRatio = availableMonsterTypes.Max(p => Configuration.MonsterRoleAttackDefenseRatios[p.Role]);
            // Consider for generating only those encounters that could possibly be generated by this list of monsters.
            var validEncounters = encounterTypeWeights.Where(encounter => (!encounter.Key.HasLeader || canHaveLeader)
                                                                      && (!encounter.Key.SpawnBossIfPossible || canHaveBoss)
                                                                      && minAttackToDefenseRatio <= encounter.Key.AttackDefenseRatio
                                                                      && encounter.Key.AttackDefenseRatio <= maxsAttackToDefenseRatio);
            var selectedEncounter = validEncounters.ToArray().GetWeightedRandomElementOrDefault(encounter => encounter.Value).Key;
            AdjustEncounterWeights(selectedEncounter);
            return selectedEncounter;
        }

        /// <summary>
        /// Call after selecting the encounter to be generated. Adjusts the weights so that this encounter becomes unlikely to be generated again in the near future.
        /// </summary>
        /// <param name="selectedEncounter">The encounter type we have selected to be generated.</param>
        private void AdjustEncounterWeights(EncounterType selectedEncounter)
        {
            foreach (var key in encounterTypeWeights.Keys.ToList())
            {
                if (key != selectedEncounter)
                {
                    encounterTypeWeights[key]++;
                }
                else
                {
                    encounterTypeWeights[key] = 1;
                }
            }
        }

        /// <summary>
        /// Initialzie the list of encounter types that could be generated by this class.
        /// </summary>
        private void FillPossibleEncounterTypes()
        {
            // TODO: Put in config
            // All weights start at 1. Whenever they are not picked, they weight, which is the likelyhood of being generated, will increase.
            encounterTypeWeights[new EncounterType(true, 1, true)] = 1;
            encounterTypeWeights[new EncounterType(true, 0.75f, true)] = 1;
            encounterTypeWeights[new EncounterType(true, 2, true)] = 1;
            encounterTypeWeights[new EncounterType(true, 0.5f, true)] = 1;
            encounterTypeWeights[new EncounterType(true, 1.5f, true)] = 1;

            encounterTypeWeights[new EncounterType(true, 1, false)] = 1;
            encounterTypeWeights[new EncounterType(true, 0.5f, false)] = 1;
            encounterTypeWeights[new EncounterType(true, 2, false)] = 1;
            encounterTypeWeights[new EncounterType(true, 0.75f, false)] = 1;
            encounterTypeWeights[new EncounterType(true, 1.5f, false)] = 1;

            encounterTypeWeights[new EncounterType(false, 1, true)] = 1;
            encounterTypeWeights[new EncounterType(false, 0.5f, true)] = 1;
            encounterTypeWeights[new EncounterType(false, 2, true)] = 1;
            encounterTypeWeights[new EncounterType(false, 0.75f, true)] = 1;
            encounterTypeWeights[new EncounterType(false, 1.5f, true)] = 1;

            encounterTypeWeights[new EncounterType(false, 1, false)] = 1;
            encounterTypeWeights[new EncounterType(false, 0.5f, false)] = 1;
            encounterTypeWeights[new EncounterType(false, 2, false)] = 1;
            encounterTypeWeights[new EncounterType(false, 0.75f, false)] = 1;
            encounterTypeWeights[new EncounterType(false, 1.5f, false)] = 1;
        }
    }
}

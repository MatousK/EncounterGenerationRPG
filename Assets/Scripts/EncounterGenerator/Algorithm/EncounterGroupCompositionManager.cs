using EncounterGenerator.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EncounterGenerator.Algorithm
{
    /// <summary>
    /// This class remembers old encounters it did generate and tries to generate new encounters that will sufficiently different from old ones.
    /// </summary>
    class EncounterGroupCompositionManager
    {
        public EncounterGeneratorConfiguration configuration;
        EncounterGroupCompositionManager()
        {
            FillPossibleEncounterTypes();
        }

        Dictionary<EncounterType, int> EncounterTypeWeights = new Dictionary<EncounterType, int>();

        public EncounterType PrepareForMonsterGroupDefinition(MonsterGroupDefinition monsterGroupDefinition)
        {
            // Go through the monsters that might be generated by this encounter and see which encounter types might be valid for those monsters.
            var allowedMonsters = monsterGroupDefinition.GetAvailableMonsterTypes();
            bool canHaveBoss = allowedMonsters.Any(p => p.Rank == MonsterRank.Boss);
            bool canHaveLeader = allowedMonsters.Any(p => p.Role == MonsterRole.Leader);
            float minAttackToDefenseRatio = allowedMonsters.Min(p => configuration.MonsterRoleAttackDefenseRatios[p.Role]);
            float maxsAttackToDefenseRatio = allowedMonsters.Min(p => configuration.MonsterRoleAttackDefenseRatios[p.Role]);
            // Consider for generating only those encounters that could possibly be generated by this monster group definition.
            var validEncounters = EncounterTypeWeights.Where(encounter => (!encounter.Key.HasLeader || canHaveLeader)
                                                                      && (!encounter.Key.SpawnBossIfPossible || canHaveBoss)
                                                                      && minAttackToDefenseRatio <= encounter.Key.AttackDefenseRatio
                                                                      && encounter.Key.AttackDefenseRatio <= maxsAttackToDefenseRatio);
            var selectedEncounter = validEncounters.ToArray().GetWeightedRandomElementOrDefault(encounter => encounter.Value).Key;
            AdjustEncounterWeights(selectedEncounter);
            return selectedEncounter;
        }



        /// <summary>
        /// Call after selecting the encounter to be generated. Adjusts the weights so that this encounter becomes unlikely to be generated again in the near future.
        /// </summary>
        /// <param name="selectedEncounter"></param>
        private void AdjustEncounterWeights(EncounterType selectedEncounter)
        {
            foreach (var key in EncounterTypeWeights.Keys)
            {
                if (key != selectedEncounter)
                {
                    EncounterTypeWeights[key]++;
                }
                else
                {
                    EncounterTypeWeights[key] = 0;
                }
            }
        }

        /// <summary>
        /// Pregenerate encounters that could be generated by this class.
        /// </summary>
        private void FillPossibleEncounterTypes()
        {
            // All weights start at 1. Whenever they are not picked, they weight, which is the likelyhood of being generated, will increase.
            EncounterTypeWeights[new EncounterType(true, 1, true)] = 1;
            EncounterTypeWeights[new EncounterType(true, 0.75f, true)] = 1;
            EncounterTypeWeights[new EncounterType(true, 2, true)] = 1;
            EncounterTypeWeights[new EncounterType(true, 0.5f, true)] = 1;
            EncounterTypeWeights[new EncounterType(true, 1.5f, true)] = 1;

            EncounterTypeWeights[new EncounterType(true, 1, false)] = 1;
            EncounterTypeWeights[new EncounterType(true, 0.5f, false)] = 1;
            EncounterTypeWeights[new EncounterType(true, 2, false)] = 1;
            EncounterTypeWeights[new EncounterType(true, 0.75f, false)] = 1;
            EncounterTypeWeights[new EncounterType(true, 1.5f, false)] = 1;

            EncounterTypeWeights[new EncounterType(false, 1, true)] = 1;
            EncounterTypeWeights[new EncounterType(false, 0.5f, true)] = 1;
            EncounterTypeWeights[new EncounterType(false, 2, true)] = 1;
            EncounterTypeWeights[new EncounterType(false, 0.75f, true)] = 1;
            EncounterTypeWeights[new EncounterType(false, 1.5f, true)] = 1;

            EncounterTypeWeights[new EncounterType(false, 1, false)] = 1;
            EncounterTypeWeights[new EncounterType(false, 0.5f, false)] = 1;
            EncounterTypeWeights[new EncounterType(false, 2, false)] = 1;
            EncounterTypeWeights[new EncounterType(false, 0.75f, false)] = 1;
            EncounterTypeWeights[new EncounterType(false, 1.5f, false)] = 1;
        }
    }
    /// <summary>
    /// We do not actually care about the exact composition of enemies in the encounter, we will just track the types.
    /// </summary>
    public class EncounterType
    {
        public EncounterType(bool hasLeader, float attackDefenseRatio, bool spawnBossIfPossible)
        {
            HasLeader = hasLeader;
            AttackDefenseRatio = attackDefenseRatio;
            SpawnBossIfPossible = spawnBossIfPossible;
        }
        /// <summary>
        /// If true, leader should be spawned as a part of this encounter.
        /// </summary>
        public bool HasLeader;
        /// <summary>
        /// How is this group balanced when talking about offense and defense.
        /// </summary>
        public float AttackDefenseRatio;
        /// <summary>
        /// The algorithm will try to spawn a boss in this combat if at all possible. If false, bosses are way less likely to appear.
        /// </summary>
        public bool SpawnBossIfPossible;
    }
}
